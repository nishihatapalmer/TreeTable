/*
 * BSD 3-Clause License
 *
 * Copyright (c) 2021, Matt Palmer
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package net.byteseek.demo.treetable;

import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.IOException;
import java.net.URISyntaxException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;
import java.util.Random;
import java.util.function.Predicate;
import javax.swing.*;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.TreeNode;
import net.byteseek.swing.treetable.TreeTableHeaderRenderer;
import net.byteseek.swing.treetable.TreeTableModel;
import net.byteseek.swing.treetable.TreeUtils;

//TODO: toggle button for group by.

public class MyObjectForm {

    public static final int MAX_LEVELS = 10;
    public static final int MAX_CHILDREN = 15;
    public static final int CHANCE_OUT_OF_TEN_FOR_CHILDREN = 4;

    public static void main(String[] args) {
        setSystemLookAndFeel();
        JFrame frame = new JFrame("TreeTable");
        MyObjectForm form = new MyObjectForm();
        form.initForm();
        frame.setContentPane(form.rootPanel);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.pack();
        frame.setVisible(true);
    }

    private static final Predicate<TreeNode> NODE_FILTER = treeNode -> ((MyObject) ((DefaultMutableTreeNode) treeNode).getUserObject()).getDescription().contains("s");

    private TreeTableModel treeTableModel;
    private DefaultTreeModel treeModel;

    private JPanel panel1;
    private JPanel rootPanel;
    private JScrollPane scrollPane;
    private JTable table1;
    private JButton showRootButton;
    private JButton insertButton;
    private JButton deleteButton;
    private JButton toggleFilterButton;
    public JTextField sTextField;
    private Random random;
    private List<String> wordList;
    private boolean showRoot;

    public MyObjectForm() {


    }

    /**
     * Split the initialization into a separate method, as had bugs with NullPointerExceptions due to components
     * not yet initialized when trying to use member components in the constructor.  The setup method is auto
     * generated by the Swing form designer in IntelliJ, doesn't seem to guarantee when it will run, or it's being
     * re-ordered somehow due to incorrect optimisation or something.  Anyway, safer to initialize after construction.
     */
    public void initForm() {
        MyObject rootObject = buildRandomTree(MAX_LEVELS, CHANCE_OUT_OF_TEN_FOR_CHILDREN);
        TreeNode rootNode = TreeUtils.buildTree(rootObject, MyObject::getChildren, parent -> !parent.getChildren().isEmpty());
        table1.setRowHeight(24);
        treeTableModel = createTreeTableModel(rootNode);
        treeModel = createTreeModel(rootNode);
        addButtonActionListeners();
    }

    private void addButtonActionListeners() {
        showRootButton.addActionListener(e -> treeTableModel.setShowRoot(!treeTableModel.getShowRoot()));

        insertButton.addActionListener(e -> {
            DefaultMutableTreeNode selectedNode = (DefaultMutableTreeNode) treeTableModel.getSelectedNode();
            MyObject newObject = new MyObject(getRandomDescription(), random.nextInt(100000000), random.nextBoolean());
            DefaultMutableTreeNode newNode = new DefaultMutableTreeNode(newObject, random.nextBoolean());
            if (treeTableModel.isExpanded(selectedNode)) { // If expanded, insert as first child:
                treeModel.insertNodeInto(newNode, selectedNode, 0);
            } else { // Insert as next sibling of selected node.
                DefaultMutableTreeNode parentNode = (DefaultMutableTreeNode) selectedNode.getParent();
                if (parentNode != null) {
                    int insertIndex = parentNode.getIndex(selectedNode) + 1;
                    treeModel.insertNodeInto(newNode, parentNode, insertIndex);
                }
            }
        });

        deleteButton.addActionListener(e -> {
            DefaultMutableTreeNode selectedNode = (DefaultMutableTreeNode) treeTableModel.getSelectedNode();
            if (selectedNode != treeTableModel.getRoot()) { // can't remove root node - will get illegal argument exception from a tree model.  use set root to change to a new root.
                treeModel.removeNodeFromParent(selectedNode);
            }
        });

        sTextField.getDocument().addDocumentListener(new DocumentListener() {
            @Override
            public void insertUpdate(DocumentEvent e) {
                updateFilter();
            }

            @Override
            public void removeUpdate(DocumentEvent e) {
                updateFilter();
            }

            @Override
            public void changedUpdate(DocumentEvent e) {
                updateFilter();
            }

            private void updateFilter() {
                if (sTextField.getText().isEmpty()) {
                    treeTableModel.setNodeFilter(null);
                } else {
                    treeTableModel.setNodeFilter(treeNode -> {
                        MyObject obj = TreeUtils.getUserObject(treeNode);
                        return !(obj.getDescription().contains(sTextField.getText()));
                    });
                }
            }
        });

        /*
        sTextField.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                // Add desired functionality here. Example:
                System.out.println("Action performed on sTextField: " + sTextField.getText());
            }
        });
        */
        //  toggleFilterButton.addActionListener(e -> treeTableModel.setNodeFilter(treeTableModel.isFiltering() ? null : NODE_FILTER));
    }

    private DefaultTreeModel createTreeModel(TreeNode rootNode) {
        DefaultTreeModel model = new DefaultTreeModel(rootNode);
        model.addTreeModelListener(treeTableModel);
        return model;
    }

    private TreeTableModel createTreeTableModel(TreeNode rootNode) {
        TreeTableModel localTreeTableModel = new MyObjectTreeTableModel(rootNode, showRoot);

        TreeTableHeaderRenderer renderer = new TreeTableHeaderRenderer();
        renderer.setShowNumber(true); // true is default, this code is just for testing the false option.

        localTreeTableModel.bindTable(table1, renderer); //, new RowSorter.SortKey(0, SortOrder.ASCENDING));
        localTreeTableModel.addExpandCollapseListener(new TreeTableModel.ExpandCollapseListener() {
            @Override
            public boolean nodeExpanding(TreeNode node) {
                if (node.getChildCount() == 0) { // if a node is expanding but has no children, set it to allow no children.
                    ((DefaultMutableTreeNode) node).setAllowsChildren(false);
                }
                return true;
            }

            @Override
            public boolean nodeCollapsing(TreeNode node) {
                return true;
            }
        });
        return localTreeTableModel;
    }

    private MyObject buildRandomTree(int maxLevels, int chanceOutOfTenForChildren) {
        random = new Random(1086);
        readWordList();
        MyObject rootObject = new MyObject(getRandomDescription(), random.nextInt(100000000), random.nextBoolean());
        buildRandomChildren(rootObject, maxLevels, chanceOutOfTenForChildren, 0, true);
        return rootObject;
    }

    private void buildRandomChildren(MyObject parent, int maxLevels, int chanceOutOfTenForChildren, int level, boolean forceChildren) {
        boolean hasChildren = level <= maxLevels && random.nextInt(10) < chanceOutOfTenForChildren;
        if (hasChildren || forceChildren) { // force children for root to ensure we get a tree and not a root without children.
            int numChildren = random.nextInt(MAX_CHILDREN) + 1;
            for (int child = 0; child < numChildren; child++) {
                MyObject childObject = new MyObject(getRandomDescription(), random.nextInt(100000000), random.nextBoolean());
                parent.addChild(childObject);
                buildRandomChildren(childObject, maxLevels, chanceOutOfTenForChildren, level + 1, false);
            }
        }
    }

    private void readWordList() {
        try {
            wordList = Files.readAllLines(getFilePath("/wordlist.txt"));
        } catch (IOException e) {
            JOptionPane.showMessageDialog(panel1, e.getMessage());
            System.exit(1);
        }
    }

    private String getRandomDescription() {
        return wordList.get(random.nextInt(wordList.size())) + ' ' + wordList.get(random.nextInt(wordList.size()));
    }

    private Path getFilePath(final String resourceName) {
        try {
            return Paths.get(this.getClass().getResource(resourceName).toURI());
        } catch (URISyntaxException e) {
            throw new RuntimeException("Invalid resource URI: " + resourceName, e);
        }
    }

    private static void setSystemLookAndFeel() {
        try {
            UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
        } catch (ClassNotFoundException | IllegalAccessException | UnsupportedLookAndFeelException e) {
            throw new RuntimeException(e);
        } catch (InstantiationException e) {
            e.printStackTrace();
            throw new RuntimeException(e);
        }
    }


    {
// GUI initializer generated by IntelliJ IDEA GUI Designer
// >>> IMPORTANT!! <<<
// DO NOT EDIT OR ADD ANY CODE HERE!
        $$$setupUI$$$();
    }

    /**
     * Method generated by IntelliJ IDEA GUI Designer
     * >>> IMPORTANT!! <<<
     * DO NOT edit this method OR call it in your code!
     *
     * @noinspection ALL
     */
    private void $$$setupUI$$$() {
        panel1 = new JPanel();
        panel1.setLayout(new BorderLayout(0, 0));
        rootPanel = new JPanel();
        rootPanel.setLayout(new GridBagLayout());
        panel1.add(rootPanel, BorderLayout.CENTER);
        scrollPane = new JScrollPane();
        GridBagConstraints gbc;
        gbc = new GridBagConstraints();
        gbc.gridx = 0;
        gbc.gridy = 1;
        gbc.gridwidth = 2;
        gbc.weightx = 1.0;
        gbc.weighty = 1.0;
        gbc.fill = GridBagConstraints.BOTH;
        rootPanel.add(scrollPane, gbc);
        table1 = new JTable();
        scrollPane.setViewportView(table1);
        final JToolBar toolBar1 = new JToolBar();
        toolBar1.setFloatable(false);
        gbc = new GridBagConstraints();
        gbc.gridx = 0;
        gbc.gridy = 0;
        gbc.gridwidth = 2;
        gbc.weightx = 1.0;
        gbc.fill = GridBagConstraints.HORIZONTAL;
        rootPanel.add(toolBar1, gbc);
        showRootButton = new JButton();
        showRootButton.setText("toggle root");
        toolBar1.add(showRootButton);
        insertButton = new JButton();
        insertButton.setText("insert");
        toolBar1.add(insertButton);
        deleteButton = new JButton();
        deleteButton.setText("delete");
        toolBar1.add(deleteButton);
        final JLabel label1 = new JLabel();
        label1.setText("Filter text  ");
        toolBar1.add(label1);
        sTextField = new JTextField();
        sTextField.setMinimumSize(new Dimension(128, 43));
        sTextField.setPreferredSize(new Dimension(128, 43));
        sTextField.setText("");
        toolBar1.add(sTextField);
    }

    /**
     * @noinspection ALL
     */
    public JComponent $$$getRootComponent$$$() {
        return panel1;
    }

}
